HORN - HTML Object RepresentatioN Specification 1.0                                                                     
===================================================                          
                                                                             
This is a specification for inlining model data into your HTML pages.

This means that your HTML can be used for the presentation of the view to the
site user, as well as being parsed out by machines - typically by JavaScript
in your page to build up the data model for your client code. This leverages
the power of the ideas from the microformats movement in a simple way for any
data schema.

By doing this, you save duplication of data and/or an AJAX round-trip on first
page load, and you have SEO-friendly data in your pages. The page your user
sees first is real semantic content.

In a nutshell, by clever use of CSS classes (or HTML5 data for only newer
browsers) and adding where necessary a few <span> or other tags to your
markup, you can provide a rich data model to your JS code from your HTML
content.

This means that your JS UI code is no longer fragile with respect to
design-related changes.

Overview
========

The basic premise of this specification is to use microformat-like techniques
to embed data in your HTML output that will be used by your scripting code
(JavaScript).

By using certain CSS classes or HTML5 data attributes in combination with
regular HTML tags, you can embed data that the user sees immediately on page
load that is also then used by the scripted code also. Your client-side data
model becomes part of the page.

Take a simple example: a page that displays a list of books, their titles and
authors - and you want the user to be able to edit and update this using
JavaScript.

With HORN you can have this HTML page render correctly without any Javascript
running, but when JavaScript does run, it has access to the array of books and
their fields - simply by calling a HORN function on page load.

Your UI can then allow the user to change data, maybe you will post it to the
server via AJAX and once confirmed, you can use HORN to automatically
re-populate the DOM nodes with the new data for that book.

This approach decouples your JavaScript from the HTML layout of the page, as
your code is not searching for DOM nodes in specific places to extract the
information it needs, the data goes back to where it originally came from.

Different data types can be parsed out of the HTML as required, with
declarative support for this in the reference implementation.

See the "examples" folder for a working example using the jQuery reference
implementation.

Weaving data into your content
==============================

There are a few different ways to inline your data in your HTML:

* Literal text seen by the user and extracted as data 
* Literal text seen by the user with an alternative value used in the data model
* Literal JSON data objects 

To define data for the model, you need to have a name for it. All data is a
property of a named object in your model "graph".

You do this by adding indicators to DOM elements. 

What are indicators?
====================

Indicators tell HORN what to do with your DOM content that represents data.

Indicators are either special CSS classes or HTML5 data attributes, depending
on your application's preference for browser support.

There are three kinds of indicator in HORN:

1. Root object indicator
2. Property path indicator
3. Inline JSON indicator

When you are not using HTML5, you define a CSS class on a DOM element. The
class name you use defines the object/value name. The only other requirement
is that some ancestor in the DOM has the "horn" class, to indicate that nodes
under that should be scanned for data. This saves HORN parsers from scanning
your entire DOM which might be slow in some browsers on complex pages, and
tells them which DOM nodes begin new "root level" data objects, rather than
nested objects.

So, to begin the data definition for a single top-level book object:

<div class="horn _book">
  ...
</div>

This HTML indicates that data for the "book" object will be defined within
this div and its descendent nodes. The underscore prefix indicates to HORN
that this is the name (minus the underscore) of your object and will be stored
as the "book" property in the root of your data model.

The rest of the examples in this specification use the CSS class indicators
until HTML5 is supported in the reference implementation.

So now we need to add the title and author information:

<div class="horn _book">
	<h1 class="_title">Presentation Zen</h1>
	<p>by <span class="_authors">Garr Reynolds</span>.</p>
</div>

The first CSS class on the div is "horn". This tells HORN that you are
starting a new root level object definition as mentioned in the previous
example, and "_book" tells it the name of this object is "book".

By using _title and _authors as classes, we are indicating HORN properties
"book.title" and "book.authors" - because they are in DOM nodes that are
descendants of the div with "horn" class. This is all you need to do to
indicate that the text inside the DOM node is a HORN value.

After applying the reference JavaScript implementation of HORN we would end up
with the equivalent of this data object accessible to our code:

{ 'book': { 'title':'Presentation Zen', 'authors':'Garr Reynolds' } }

Of course the most important part here is that this is also immediately
displayed to the user even without JS code loaded or running, and indexable by
search engines. When your JS code changes it later, it can feed straight back
into the DOM nodes.

Now let's say we want to show the genre, but internally this genre is
represented by a code or unique id - we use the HTML <abbr> tag:

<div class="horn _book">
	<h1 class="_title">Presentation Zen</h1>
	<p>
		by <span class="_authors">Garr Reynolds</span> 
		in genre <abbr class="_genre" title="GENRE_BUSINESS">Business</abbr>.
	</p>
</div>

This is declaring that while the display value of the genre is "Business", the
value to put into "book.genre" is "GENRE_BUSINESS".

Next let's add the publication date. However for the sake of usability we may
be showing a short date to the user, but we still need the full date object
for our JS code to work with:

<div class="horn _book">
	<h1 class="_title">Presentation Zen</h1>
	<p>
		Written by <span class="_authors">Garr Reynolds</span> 
		in genre <abbr class="_genre" title="GENRE_BUSINESS">Business</abbr>
		published <abbr class="_publishDate" title="10/02/2011">10 Feb</abbr>.
	</p>
</div>

Here, you will typically want the parser implementation to convert the date
string into a native JavaScript date. This is not something covered by the
HORN specification itself, but the HORN 1.0 reference implementation allows
you to do this using meta tags in the <head> section of your page:

<meta name="typeof book.*date" content="DateConverter"/>

This declares that any property path ending with "date" will be parsed as a
Date, using a JS class to perform the conversion using toText()/fromText()
methods. This lets you build up your model with native JavaScript types so
that it isn't just an object with string property values.

Now we might also need to add some unique id information so that we can tally
up this object to the book in the database during AJAX calls. For this we use
in inline json mechanism:

<div class="horn _book">
	<p class="horn-json hidden">{ 'id':384855 }</p>
	<h1 class="_title">Presentation Zen</h1>
	<p>
		Written by <span class="_authors">Garr Reynolds</span> 
		in genre <abbr class="_genre" title="GENRE_BUSINESS">Business</abbr>
		published <abbr class="_publishDate" title="10/02/2011">last month</abbr>.
	</p>
</div>

Now this isn't something we necessarily want the user to see, so we may apply
a "hidden" CSS class to the content (this is not defined as part of the specification).

What this does is tell your HORN parser that the text nodes inside the <p> tag
with "horn-json" are to be merged with the "current" object. Current object
means the object named by the nearest element with the "horn" class in DOM
ancestry terms.

Note that JSON data is not subject to the type conversions declared, it is
assumed your JSON data is in the native JSON type that you require.

So with all the above, we'd end up with a data model the equivalent of this
JSON data model:

{ 
   'book': { 
		'title': 'Presentation Zen', 
		'authors': 'Garr Reynolds',
		'genre': 'GENRE_BUSINESS',
		'publishDate': new Date(234857489357),
		'id': 384855
	} 
}

How you access this is up to the parser implementation you use, but for the
jQuery reference implementation you will use something like:

var horn = new Horn()
var myModel = horn.extract()

The rules: how HORN knows what is a value
=========================================

HORN parsers apply some simple rules to determine whether or not a tag contains a
data value and what to do with it:

1. If a DOM element is marked as a HORN context root (has class "horn") and
has a property path (has class like "_yourpropname"), a new root-level data
object will be declared.

2. If a DOM element is NOT marked as a HORN context root, and has only a
property path indicated:
   AND a) it has only text nodes as children, it will be used to set a property 
      (according to the path defined) on the "current" object.
   OR  b) if the tag is an <abbr> tag, the "title" attribute will be used to set
      the value.
   OR  c) Otherwise it will just be added to the current property path.

3. If a DOM element has the horn-json indicator and a property path, the text
of the child nodes will be parsed as JSON and merged into the model relative
to the current property path.

4. If a DOM element has no HORN indicators on it, it is ignored.


Property path indicators
=====================================

For pre-HTML5 applications, the HORN specification uses CSS classes to
indicate root contexts and property paths. For HTML5 it uses HTML-Data
attributes.

The constraints on valid characters in CSS classes mean that we have to use a
slightly awkward syntax to provide identifiable classes that can act as
property paths.

The pattern is that all HORN property path classes begin with an underscore
and then the first object name. Underscores are used to separate each nested
property, including array indexes:

Property path ----> CSS class
-------------------------------
book ----> _book
book.title ----> _book_title
books[0] ----> _books_0
books[0].title ----> _books_0_title
books[3].authors[2].name.firstName ----> _books_3_authors_2_name_firstName

These show absolute property paths. In most common usage however you will use
property paths relative to the nearest ancestor's calculated path:

<div class="horn _books">
	<div class="_0">
	    <span class="_title">XML Complete</span><br/>
	    by <span class="_author">by Steven Holzner</span><br/>
	    <ol>
	        <li>Publisher: <span class="_publisher">McGraw-Hill</span></li>
	        <li>ISBN: <span class="_isbn">0-079-13702-4</span></li>
	        <li>Pages: <span class="_pages">600</span></li>
	        <li>Price: $<span class="_price">44.95</span></li>
	        <li>Publication Date: <span class="_pubDate">01 December 1997</span></li>
	    </ol>
	</div>
</div>

You can see here that inner elements have spans defining data properties which
will be set on books[0].


Complex data: nested objects and arrays
=======================================

HORN fully supports object graphs and arrays.

To specify that an element is part of an array, you simply make the property
path include a numeric identifier that is the array index. HORN
implementations treat this as an array index and create a JS array to contain
the values or objects:

<div class="horn _books">
	<div class="_0">
		<p class="horn-json hidden">{ 'id':384855 }</p>
		<h1 class="_title">Presentation Zen</h1>
		<p>
			Written by <span class="_authors">Garr Reynolds</span> 
			in genre <abbr class="_genre" title="GENRE_BUSINESS">Business</abbr>
			published <abbr class="_publishDate" title="10/02/2011">last month</abbr>.
		</p>
	</div>

	<div class="horn _books-1">
		<p class="horn-json hidden">{ 'id':384855 }</p>
		<h1 class="_title">Reality Check</h1>
		<p>
			Written by <span class="_authors">Guy Kawasaki</span> 
			in genre <abbr class="_genre" title="GENRE_BUSINESS">Business</abbr>
			published <abbr class="_publishDate" title="13/10/2010">last year</abbr>.
		</p>
	</div>
</div>

The above defines a "books" property in the model that will be an array with
two elements, 0 and 1.

To nest objects, for example a publisher information object, you simply nest
DOM nodes and apply property name indicators:

<div class="horn _books-0">
	<p class="horn-json hidden">{ 'id':384855 }</p>
	<h1 class="_title">Presentation Zen</h1>
	<p>
		Written by <span class="_authors">Garr Reynolds</span> 
		in genre <abbr class="_genre" title="GENRE_BUSINESS">Business</abbr>
		published <abbr class="_publishDate" title="10/02/2011">last month</abbr>.
	</p>
	<div class="_publisher">
		<h2 class="_name">New Riders</h2>
	</div>
</div>

This defines "books[0].publisher.name" as "New Riders".
